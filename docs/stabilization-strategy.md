# Stabilization Strategy

Документ про то, как держать форк в рабочем состоянии при регулярном подтягивании upstream.

## 1. Операционная цель

Не "сделать идеальную архитектуру", а удерживать предсказуемость в трех критичных плоскостях:

1. навигация и URL-контракт;
2. сборка/типизация (`ui`, `server`, `dist-lib`);
3. graph complexity (циклы и растущий техдолг).

## 2. Инварианты форка

Перед и после каждого sync-инкремента должны сохраняться:

1. canonical entry URL-конструкторы остаются источником истины;
2. внутренние ссылки нормализуются перед отдачей в `href`/router;
3. быстрый пакет guardrails проходит без расширения бюджетов;
4. сборка `dist-lib` остается воспроизводимой.

## 3. Ритм проверки изменений

Минимальный ритм:

1. до интеграции upstream: baseline `ci:upstream:quick`;
2. после интеграции: повтор baseline + полный `ci:upstream`;
3. при расхождении: сначала патч навигации/контракта, затем остальные зоны.

## 4. Приоритеты патчей (в порядке важности)

1. broken navigation/deep links;
2. lock/revision flow regressions;
3. create-flow regressions (`connection -> dataset -> chart -> dashboard`);
4. capability/permission regressions;
5. non-critical refactors и локальные улучшения читаемости.

## 5. Политика по техническому долгу

1. бюджетный подход вместо "переписать всё";
2. новые suppressions (`ts-ignore`, `eslint-disable`) только с явной причиной;
3. бюджеты можно повышать только осознанным решением и отдельной фиксацией.

## 6. Что не делать в sync-цикле

1. не совмещать большой архитектурный рефактор и merge upstream в одном PR/коммите;
2. не расползаться по всей кодовой базе при одном локальном регрессе;
3. не менять URL-контракт без обновления документов и guardrails.
